# -*- coding: utf-8 -*-
"""qaoa.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yPojEh1Hfy45r9QMFNX8MmNeu-H23bL9
"""

# run this in your terminal before getting started: pip install qiskit numpy networkx

from __future__ import annotations

import numpy as np
import networkx as nx

# create a graph with 4 nodes
nodes = 4
w = np.array([[0., 1., 1., 0.],
              [1., 0., 1., 1.],
              [1., 1., 0., 1.],
              [0., 1., 1., 0.]])
G = nx.from_numpy_array(w)

# visualize graph
layout = nx.random_layout(G, seed=10)
colors = ['r', 'g', 'b', 'y']
nx.draw(G, layout, node_color=colors)
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos=layout, edge_labels=labels)

def objective_value(x: np.ndarray, w: np.ndarray) -> float:
    """
    Compute the value of a cut.
    """
    X = np.outer(x, (1 - x))
    w_01 = np.where(w != 0, 1, 0)
    return np.sum(w_01 * X)

def bitfield(n: int, L: int) -> list[int]:
    result = np.binary_repr(n, L)
    return [int(digit) for digit in result]  # [2:] to chop off the "0b" part

from qiskit.quantum_info import Pauli, SparsePauliOp

# convert our graph to an Ising Hamiltonian constant

def get_operator(weight_matrix: np.ndarray) -> tuple[SparsePauliOp, float]:
    """
    Generate the Hamiltonian for the graph partitioning by 
    seperating the graph vertices into two sets of the same size,
    then making sure the number of edges between the two sets
    is at a minimum.
    """
    
    nodes = len(weight_matrix)
    pauli_list, coeffs = [], []
    shift = 0

    for i in range(nodes):
        for j in range(i):
            if weight_matrix[i, j] != 0:
                x_p = np.zeros(nodes, dtype=bool)
                z_p = np.zeros(nodes, dtype=bool)
                z_p[i] = True
                z_p[j] = True
                pauli_list.append(Pauli((z_p, x_p)))
                coeffs.append(-0.5)
                shift += 0.5

    for i in range(nodes):
        for j in range(nodes):
            if i != j:
                x_p = np.zeros(nodes, dtype=bool)
                z_p = np.zeros(nodes, dtype=bool)
                z_p[i] = True
                z_p[j] = True
                pauli_list.append(Pauli((z_p, x_p)))
                coeffs.append(1.0)
            else:
                shift += 1

    return SparsePauliOp(pauli_list, coeffs=coeffs), shift

qubit_op, offset = get_operator(w)

from qiskit.algorithms.minimum_eigensolvers import QAOA
from qiskit.algorithms.optimizers import COBYLA
from qiskit.circuit.library import TwoLocal
from qiskit.primitives import Sampler
from qiskit.quantum_info import Pauli, Statevector
from qiskit.result import QuasiDistribution
from qiskit.utils import algorithm_globals

# implement quantum approximate optimization algorithm

sampler = Sampler()

def sample_most_likely(state_vector: QuasiDistribution | Statevector) -> np.ndarray:
    """
    Compute the most likely binary string from state vector.
    """
    if isinstance(state_vector, QuasiDistribution):
        values = list(state_vector.values())
    else:
        values = state_vector
    n = int(np.log2(len(values)))
    k = np.argmax(np.abs(values))
    x = bitfield(k, n)
    x.reverse()
    return np.asarray(x)

algorithm_globals.random_seed = 10598

optimizer = COBYLA()
qaoa = QAOA(sampler, optimizer, reps=2)

result = qaoa.compute_minimum_eigenvalue(qubit_op)

x = sample_most_likely(result.eigenstate)

print(f'The most likely binary string is {x}')
print(f'The value computed by QAOA is {objective_value(x, w)}')